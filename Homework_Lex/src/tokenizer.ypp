%{
    /*************************************************************
    expr.l
    LEX FILE
    Date: 2021/10/18
    Haobin Chen (@Aoyamahiroki) <etyyuiope@gmail.com>
    Jiawei Xu   (@Darren-8)

    Main tokenizer
    **************************************************************/
    #include <item_ident.hh>
    #include <symbol_table.hh>
    
    #include <iostream>
    #include <fstream>
    #include <string>
    #include <stdexcept>

    extern compiler::Symbol_table symbol_table;
    extern uint32_t yylineno;

    extern int yylex(void);
    extern int yyparse(void);
    extern void yyerror(const char* str);
    extern FILE* yyin;
%}
%token          ID
%error-verbose
%union {
    char*   raw_symbol;
    char*   raw_string;
    int     raw_int;
    double  raw_real;
}

// Operators 
%token          ADD MINUS MUL DIV MOD
%token          EQ NEQ GEQ LEQ G L
%token          BIT_AND BIT_OR BIT_XOR BIT_NEG
%token          LOGIC_AND LOGIC_OR LOGIC_NOT

// Numbers and string
%token          DECIMAL OCTAL HEX STRING

// Types
%token          INT DOUBLE FLOAT CHAR VOID STRUCT

// Keywords
%token          IF ELSE WHILE FOR RETURN BREAK CONTINUE CONST ASSIGN

// Other symbols
%token          LBRACE RBRACE LPARENTHESIS RPARENTHESIS
%token          SEMICOLON

%right          ASSIGN
%left           ADD MINUS
%left           MOD
%left           MUL DIV
%nonassoc       UMINUS UADD

%start lines

%type <raw_symbol> ID
%type <raw_int>    DECIMAL

%%
lines: lines assignment SEMICOLON
     | assignment       SEMICOLON
     ;

assignment:
INT ID ASSIGN DECIMAL {
    compiler::Item_ident *const item = new compiler::Item_ident_int(yylineno, $2, symbol_table.get_current_scope(), $4);
    symbol_table.put(item);
}   |
    ;

%%
int main(int argc, const char** argv)
{
    try {
        if (argc != 3) {
            throw std::runtime_error("Not enough arguments!");
        }

        yyin = fopen(argv[1], "r");

        do {
            yyparse();
        } while (!feof(yyin));
    } catch (const std::runtime_error& e) {
        // std::cerr << line_count << " " << cur_pos << ":\t" <<  e.what() << std::endl;
    }
    return 0;
}