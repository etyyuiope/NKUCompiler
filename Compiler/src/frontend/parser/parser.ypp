%{
    /*************************************************************
    parser.ypp
    LEX FILE
    Date: 2021/10/18
    Haobin Chen (@Aoyamahiroki) <etyyuiope@gmail.com>
    Jiawei Xu   (@Darren-8)

    Main tokenizer
    **************************************************************/
    #include <frontend/nodes/item_all.hh>
    #include <frontend/nodes/config.hh>
    #include <frontend/symbol_table.hh>
    
    #include <iostream>
    #include <fstream>
    #include <string>
    #include <stdexcept>

    extern compiler::Symbol_table symbol_table;
    extern uint32_t yylineno;

    extern int yylex(void);
    extern int yyget_lineno(void);
    extern int yylex_destroy();
    extern int yyparse(void);

    # define YYLLOC_DEFAULT(Cur, Rhs, N)                          \
    do {                                                          \
        if (N) {                                                  \
            (Cur).first_line   = YYRHSLOC(Rhs, 1).first_line;     \
            (Cur).first_column = YYRHSLOC(Rhs, 1).first_column;   \
            (Cur).last_line    = YYRHSLOC(Rhs, N).last_line;      \
            (Cur).last_column  = YYRHSLOC(Rhs, N).last_column;    \
        } else {                                                  \
            (Cur).first_line   = (Cur).last_line   =              \
                YYRHSLOC(Rhs, 0).last_line;                       \
            (Cur).first_column = (Cur).last_column =              \
                YYRHSLOC(Rhs, 0).last_column;                     \
        }                                                         \
    } while (0)

    void yyerror(const char* str)
    {
        std::cerr << yylloc.first_line << ':'
                  << yylloc.first_column << " : [ERROR]: " << str << std::endl;
        yylex_destroy();
    }

    extern FILE* yyin;
%}
%locations
%error-verbose

%union {
    compiler::Item_root*            item_root;               // root
    compiler::Item_decl*            item_decl;
    compiler::Item_stmt_decl*       item_stmt_decl;
}

%token          ID
// Operators 
%token          ADD MINUS MUL DIV MOD
%token          EQ NEQ GEQ LEQ G L
%token          BIT_AND BIT_OR BIT_XOR BIT_NEG
%token          LOGIC_AND LOGIC_OR LOGIC_NOT
// Numbers and string
%token          DECIMAL OCTAL HEX STRING
// Types
%token          INT DOUBLE FLOAT CHAR VOID STRUCT
// Keywords
%token          IF ELSE WHILE FOR RETURN BREAK CONTINUE CONST ASSIGN
// Other symbols
%token          LBRACE RBRACE LPARENTHESIS RPARENTHESIS LSQUARE RSQUARE
%token          SEMICOLON DOT COMMA

%left COMMA
%left ASSIGN
%left EQ NE L LE G GE
%left ADD MINUS
%left MUL DIV MOD
%left LOGIC_NOT
%nonassoc UMINUS UADD

// Type definition
%type <item_root> CompUnit
%type <item_stmt_decl> Decl
%type <item_func_def> FuncDef

%start CompUnit
%%

CompUnit: CompUnit Decl         { $$->add_child($<item_decl>2); }
        | CompUnit FuncDef      { $$->add_child($<item_func_def>2); }
        | Decl                  { $$ = new compiler::Item_root(yyget_lineno()); compiler::root = $$; $$->add_child($<item_decl>1); }
        | FuncDef               { $$ = new compiler::Item_root(yyget_lineno()); compiler::root = $$; $$->add_child($<item_func_def>1); }
        ;

Decl: VarDecl
    | ConstDecl
    ;
%%