%{
    /*************************************************************
    parser.ypp
    LEX FILE
    Date: 2021/10/18
    Haobin Chen (@Aoyamahiroki) <etyyuiope@gmail.com>
    Jiawei Xu   (@Darren-8)

    Main tokenizer
    **************************************************************/
    #include <common/config.hh>
    #include <common/types.hh>
    #include <frontend/nodes/item_all.hh>
    #include <frontend/symbol_table.hh>

    #include "test.hh"
    
    #include <iostream>
    #include <fstream>
    #include <string>
    #include <stdexcept>

    extern compiler::Symbol_table symbol_table;
    extern uint32_t yylineno;

    extern int yylex(void);
    extern int yyget_lineno(void);
    extern int yylex_destroy();
    extern int yyparse(void);

    # define YYLLOC_DEFAULT(Cur, Rhs, N)                          \
    do {                                                          \
        if (N) {                                                  \
            (Cur).first_line   = YYRHSLOC(Rhs, 1).first_line;     \
            (Cur).first_column = YYRHSLOC(Rhs, 1).first_column;   \
            (Cur).last_line    = YYRHSLOC(Rhs, N).last_line;      \
            (Cur).last_column  = YYRHSLOC(Rhs, N).last_column;    \
        } else {                                                  \
            (Cur).first_line   = (Cur).last_line   =              \
                YYRHSLOC(Rhs, 0).last_line;                       \
            (Cur).first_column = (Cur).last_column =              \
                YYRHSLOC(Rhs, 0).last_column;                     \
        }                                                         \
    } while (0)

    void yyerror(const char* str)
    {
        std::cerr << yylloc.first_line << ':'
                  << yylloc.first_column << " : [ERROR]: " << str << std::endl;
        yylex_destroy();
    }

    extern FILE* yyin;
%}
%locations
%error-verbose

%union {
    compiler::basic_type                btype;
    compiler::Item_root*                item_root;               // root
    compiler::Item_decl*                item_decl;
    compiler::Item_stmt_decl*           item_stmt_decl;
    compiler::Item_func_def*            item_func_def;
    compiler::Item_expr*                item_expr;
    compiler::Item_ident*               item_ident;
    compiler::Item_ident_array*         item_ident_array;
    compiler::Item_decl_array_init*     item_decl_array_init;
    compiler::Item_literal_array_init*  item_literal_array_init;
    compiler::Item_decl_var*            item_decl_var;
    compiler::Item_decl_var_init*       item_decl_var_init;
    compiler::Item_func_def_list*       item_func_def_list;
    compiler::Item_func_def_arg*        item_func_def_arg;
    compiler::Item_block*               item_block;
    std::string*                        raw_string;
}

%token          ID
// Operators 
%token          ADD MINUS MUL DIV MOD
%token          EQ NEQ GEQ LEQ G L
%token          BIT_AND BIT_OR BIT_XOR BIT_NEG
%token          LOGIC_AND LOGIC_OR LOGIC_NOT
// Numbers and string
%token          DECIMAL OCTAL HEX STRING
// Types
%token          INT DOUBLE FLOAT CHAR VOID STRUCT
// Keywords
%token          IF ELSE WHILE FOR RETURN BREAK CONTINUE CONST ASSIGN
// Other symbols
%token          LBRACE RBRACE LPARENTHESIS RPARENTHESIS LSQUARE RSQUARE
%token          SEMICOLON DOT COMMA

%left COMMA
%left ASSIGN
%left EQ NE L LE G GE
%left ADD MINUS
%left MUL DIV MOD
%left LOGIC_NOT
%nonassoc UMINUS UADD

// Type definition
%type <btype> BType
%type <item_block> BLOCK
%type <item_root> CompUnit
%type <item_stmt_decl> Decl ConstDecl VarDecl ConstDeclStmt VarDeclStmt
%type <item_func_def> FuncDef
%type <item_func_def_list> FuncDefList
%type <item_func_def_arg> FuncParam FuncParamNormal FuncParamArray
%type <item_decl> VarDef VarDefNormal VarDefArray ConstDef ConstDefNormal ConstDefArray
%type <item_expr> Exp AddExp BitExp
%type <item_ident> Ident
%type <item_ident_array> ArrayID
%type <item_literal_array_init> ArrayInitVal ArrayInitValHelper

%type <raw_string> ID

%start CompUnit
%%

CompUnit: CompUnit Decl         { $$->add_child($<item_decl>2); }
        | CompUnit FuncDef      { $$->add_child($<item_func_def>2); }
        | Decl                  { $$ = new compiler::Item_root(yyget_lineno()); compiler::root = $$; $$->add_child($<item_decl>1); }
        | FuncDef               { $$ = new compiler::Item_root(yyget_lineno()); compiler::root = $$; $$->add_child($<item_func_def>1); }
        ;

Decl: VarDeclStmt
    | ConstDeclStmt
    ;

VarDeclStmt: VarDecl SEMICOLON { $$ = $1; }
           ;

ConstDeclStmt: ConstDecl SEMICOLON { $$ = $1; }
             ;

BType: INT                      { $$ = compiler::basic_type::INT_TYPE; }
     | DOUBLE                   { $$ = compiler::basic_type::REAL_TYPE; }
     | FLOAT                    { $$ = compiler::basic_type::REAL_TYPE; }
     | CHAR                     { $$ = compiler::basic_type::CHAR_TYPE; }
     ;

VarDecl: BType VarDef               { $$ = new compiler::Item_stmt_decl(yyget_lineno(), $1); $$->add_declaration($2); }
       | VarDecl COMMA VarDef       { $$->add_declaration($3); }
       ;

ConstDecl: CONST BType ConstDef      { $$ = new compiler::Item_stmt_decl(yyget_lineno(), $2); $$->add_declaration($3); }
         | ConstDecl COMMA ConstDef  { $$->add_declaration($3); }
         ;

VarDef: VarDefNormal
      | VarDefArray
      ;

VarDefNormal: Ident ASSIGN Exp             { $$ = new compiler::Item_decl_var_init(yyget_lineno(), $1, $3, false); }
            | Ident                        { $$ = new compiler::Item_decl_var(yyget_lineno(), $1); }
            ;

VarDefArray: ArrayID ASSIGN ArrayInitVal    { $$ = new compiler::Item_decl_array_init(yyget_lineno(), $1, $3, false); }
           | ArrayID                        { $$ = new compiler::Item_decl_array(yyget_lineno(), $1); }
           ;

ArrayID: ArrayID LSQUARE Exp RSQUARE        { $$ = $1; $$->add_shape($3); }
       | Ident LSQUARE Exp RSQUARE             { $$ = new compiler::Item_ident_array(yyget_lineno(), $1->get_name()); $$->add_shape($3); }
       ;

ArrayInitVal: LBRACE ArrayInitValHelper RBRACE             { $$ = $2; }
            | LBRACE RBRACE                                { $$ = new compiler::Item_literal_array_init(yyget_lineno(), nullptr, false); }
            ;

ConstDef: ConstDefNormal                
        | ConstDefArray
        ;

ConstDefNormal: Ident ASSIGN Exp           { $$ = new compiler::Item_decl_var_init(yyget_lineno(), $1, $3, true); }
              ;

ConstDefArray: ArrayID ASSIGN ArrayInitVal      { $$ = new compiler::Item_decl_array_init(yyget_lineno(), $1, $3, true); }
             ;

FuncDef: BType Ident LPARENTHESIS FuncDefList RPARENTHESIS BLOCK    { $$ = new compiler::Item_func_def(yyget_lineno(), $1, $2, $4, $6); }
       | VOID  Ident LPARENTHESIS FuncDefList RPARENTHESIS BLOCK    { $$ = new compiler::Item_func_def(yyget_lineno(), compiler::basic_type::VOID_TYPE, $2, $4, $6); }
       | BType Ident LPARENTHESIS RPARENTHESIS BLOCK                { $$ = new compiler::Item_func_def(yyget_lineno(), $1, $2, new compiler::Item_func_def_list(yyget_lineno()), $5); }
       | VOID  Ident LPARENTHESIS RPARENTHESIS BLOCK                { $$ = new compiler::Item_func_def(yyget_lineno(), compiler::basic_type::VOID_TYPE, $2, new compiler::Item_func_def_list(yyget_lineno()), $5); }
       ;

FuncDefList: FuncDefList COMMA FuncParam        { $$->add_arg($3); }
           | FuncParam                          { $$ = new compiler::Item_func_def_list(yyget_lineno()); $$->add_arg($1); }
           ;

FuncParam: FuncParamNormal
         | FuncParamArray
         ;

FuncParamNormal: BType Ident       { $$ = new compiler::Item_func_def_arg(yyget_lineno(), $1, $2); }
               ;

FuncParamArray: BType Ident LSQUARE RSQUARE                {
                                                            compiler::Item_ident_array* ident = new compiler::Item_ident_array(yyget_lineno(), $2->get_name());
                                                            ident->add_shape(new compiler::Item_literal_int(yyget_lineno(), 1));
                                                            $$ = new compiler::Item_func_def_arg(yyget_lineno(), $1, ident);
                                                        }
              | FuncParamArray LSQUARE RSQUARE          { $$ = $1; static_cast<compiler::Item_ident_array*>($$->get_identifier())->add_shape(new compiler::Item_literal_int(yyget_lineno(), 1)); }
              ;

Ident: ID       { $$ = new compiler::Item_ident(yyget_lineno(), *$1); }
     ;

ArrayInitValHelper: 'foo';

BLOCK: ;

Exp: BitExp
   ;

BitExp: AddExp
      ;

AddExp: ;


%%